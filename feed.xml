<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://mhoo999.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://mhoo999.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-17T08:02:38+00:00</updated><id>https://mhoo999.github.io/feed.xml</id><title type="html">TechHoonology</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">[백준] 15650번 N과 M (2) / C++</title><link href="https://mhoo999.github.io/blog/2024/boj15650/" rel="alternate" type="text/html" title="[백준] 15650번 N과 M (2) / C++"/><published>2024-05-17T00:00:00+00:00</published><updated>2024-05-17T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj15650</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj15650/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/15650">백준 15650번 N과 M (2)</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="cp">#define MAX 9
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">arr</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

	<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>n개의 배열을 m개의 열로 중복 없이 출력하는 문제. 중복된 수 조합이 출려되면 안 되므로 dfs를 사용하여 해결.</p>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry><entry><title type="html">[백준] 2579번 계단 오르기 / C++</title><link href="https://mhoo999.github.io/blog/2024/boj2579/" rel="alternate" type="text/html" title="[백준] 2579번 계단 오르기 / C++"/><published>2024-05-16T00:00:00+00:00</published><updated>2024-05-16T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj2579</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj2579/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/2579">백준 2579번 계단 오르기</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">stair</span><span class="p">[</span><span class="mi">301</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">301</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>

		<span class="n">stair</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stair</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">stair</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">stair</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">stair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stair</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stair</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">stair</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>n개의 계단이 주어진다. 각 계단은 점수를 가지고 있으며, 점수가 없는 0번 계단부터 1칸씩 또는 2칸씩 오를 수 있다. 연속으로 1칸씩 3계단 이상 오를 수 없으며, 마지막 계단은 꼭 밟아야 한다. 모든 규칙을 준수하여 올랐을 때, 가장 높은 점수를 출력하는 문제다.<br/> 각 계단의 최고 점수를 출력한다면…</p> <ol> <li>n = 1, 계단 1칸</li> <li>n = 2, 계단 1칸 + 계단 2칸</li> <li>n = 3, 계단 1칸 + 계단 3칸 vs 계단 2칸 + 계단 3칸(연속으로 3칸 올라갈 수 없으니까)</li> <li>n = 4, 계단 1칸 + 계단 2칸 + 계단 4칸 vs 계단 1칸 + 계단 3칸 + 계단 4칸</li> <li>n = 5, 계단 3칸(점수) + 계단 5칸 vs 계단 1칸(점수) + 계단 4칸 + 계단 5칸 위의 규칙을 사용해 DP를 만들어 해결. 보자마자 DP로 해결해야 되겠다는 건 느꼈지만, 점화식을 도출하는 데 시간이 걸렸다.</li> </ol>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry><entry><title type="html">[백준] 11726번 2xn 타일링 / C++</title><link href="https://mhoo999.github.io/blog/2024/boj11726/" rel="alternate" type="text/html" title="[백준] 11726번 2xn 타일링 / C++"/><published>2024-05-15T00:00:00+00:00</published><updated>2024-05-15T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj11726</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj11726/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/11726">백준 11726번 2xn 타일링</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1001</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="mi">10007</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>2<em>n 크기의 직사각형을 1</em>2, 2<em>1 타일로 채우는 방법의 수를 구하는 문제. 2</em>1 - 2*5 크기의 직사각형을 수기로 채워봤더니, 방법의 수가 피보나치 수열 규칙을 가지고 있는 것을 발견할 수 있었다. 출력 시 10,007로 나눈 나머지를 출력해야 하기 때문에 10,007로 나누어 저장하고, 출력하여 해결.</p>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry><entry><title type="html">[백준] 1003번 피보나치 함수 / C++</title><link href="https://mhoo999.github.io/blog/2024/boj1003/" rel="alternate" type="text/html" title="[백준] 1003번 피보나치 함수 / C++"/><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj1003</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj1003/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/1003">백준 1003번 피보나치 함수</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">prev1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">prev2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">fn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">prev1</span> <span class="o">+</span> <span class="n">prev2</span><span class="p">;</span>

			<span class="n">prev1</span> <span class="o">=</span> <span class="n">prev2</span><span class="p">;</span>
			<span class="n">prev2</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">fn</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">t</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>n번째 피보나치 수열이 불리는데, 0과 1이 몇번이 호출되는지 차례로 출력하는 문제. 재귀 함수로 된 Fibonacci 함수 예시를 제공한다. 처음 시도에서는 변수 x, y를 만들어 각각 피보나치 함수 내 <code class="language-plaintext highlighter-rouge">if (n == 0)</code>과 <code class="language-plaintext highlighter-rouge">if (n == 1)</code>에서 증가연산을 하고 호출되는 갯수를 출력했다. 답은 맞았지만 시간초과로 문제는 틀렸다. 하지만 0의 호출 갯수는 <code class="language-plaintext highlighter-rouge">Fibonacci(n - 1)</code>, 1의 호출 갯수는 <code class="language-plaintext highlighter-rouge">Fibonacci(n)</code>과 동일함을 알 수 있었다. 그리고 피보나치 수열을 반복문으로 작성할 경우 O(n)의 시간복잡도를 가지는데, 재귀함수의 경우 O(2^n)의 시간 복잡도를 가지기 때문에 성능 차이가 굉장히 크다. 코드를 반복문으로 변경하여 해결했다.</p>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry><entry><title type="html">[백준] 1929번 소수 구하기 / C++</title><link href="https://mhoo999.github.io/blog/2024/boj1929/" rel="alternate" type="text/html" title="[백준] 1929번 소수 구하기 / C++"/><published>2024-05-13T00:00:00+00:00</published><updated>2024-05-13T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj1929</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj1929/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/1929">백준 1929번 소수 구하기</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">isPrimeNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isPrimeNumber</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>m이상 n이하의 소수를 모두 출력하는 프로그램을 작성하는 문제. 소수를 찾는 알고리즘을 만드는 데 유용한 6k ± 1 최적화 방법을 사용하여 해결했다. 이 테크닉은 모든 소수가 6의 배수 양 옆 혹은 6의 배수를 제외한 6k ± 1형태로 존재한다는 관찰에 기반한다. <br/> <a href="https://mhoo999.github.io/blog/2024/findPrimeNumber/">소수를 빠르게 찾는 방법</a></p>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry><entry><title type="html">소수를 빠르게 찾는 방법</title><link href="https://mhoo999.github.io/blog/2024/findPrimeNumber/" rel="alternate" type="text/html" title="소수를 빠르게 찾는 방법"/><published>2024-05-13T00:00:00+00:00</published><updated>2024-05-13T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/findPrimeNumber</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/findPrimeNumber/"><![CDATA[<p>6k ± 1 최적화 방법은 소수를 찾기 위한 알고리즘에서 매우 유용한 테크닉이다. 이 방법은 모든 소수가 6의 배수 양 옆 혹은 6의 배수를 제외한 6k ± 1 형태로 존재한다는 관찰에 기반한다.</p> <h3 id="수학적-배경">#수학적 배경</h3> <p>6의 배수를 생각해보면, 6k(k는 자연수)는 항상 2와 3의 공배수다. 따라서 소수는 6k에서 발생할 수 없다. 이제 6k 주변을 살펴보면 다음과 같은 형태를 갖게 된다.</p> <ul> <li>6k - 2 = 2(3k - 1) : 2의 배수</li> <li>6k - 3 = 3(2k - 1) : 3의 배수</li> <li>6k : 2와 3의 공배수</li> <li>6k + 2 = 2(3k + 1) : 2의 배수</li> <li>6k + 3 = 3(2k + 1) : 3의 배수</li> </ul> <p>위에서 보듯, 6k - 2, 6k - 3, 6k + 2, 6k + 3 모두 2 또는 3의 배수이기 때문에 소수가 발견될 수 없다. 결과적으로 6의 배수가 아닌 수 중에서 소수를 찾을 가능성이 있는 것은 오직 6k - 1과 6k + 1 뿐이다. 이 두 형태는 6의 배수를 기준으로 앞뒤에 위치하며, 2나 3의 배수가 아닌 경우에 소수일 가능성이 있다.</p> <h3 id="알고리즘-구현">#알고리즘 구현</h3> <p>이 관찰을 통해 소수 판별 함수나 에라토스테네스의 체 알고리즘을 최적화할 수 있다. 일반적으로 소수 판별 시에 모든 수를 확인하는 대신, 6k ± 1 형태에 해당하는 수들만 검사하면 계산량을 줄일 수 있다. 다음은 6k ± 1 최적화를 포함한 C++ 소수 판별 함수다.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span>
<span class="kt">bool</span> <span class="nf">isPrime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 1 이하는 소수가 아님</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// 2와 3은 소수</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 2 또는 3으로 나누어 떨어지면 소수가 아님</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 6k - 1 및 6k + 1 형태 검사</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="성능-향상">#성능 향상</h3> <p>이 최적화 방법은 소수를 찾는 알고리즘의 효율을 상당히 향상시킨다. 특히 큰 숫자를 대상으로 할 때, 6의 배수에 대한 배제로 인해 필요한 계산량을 대폭 줄일 수 있다. 그러나 이 방법이 소수를 찾는 데 필요한 모든 계산을 제거하는 것은 아니며, 6k ± 1 형태의 수들 중에서도 실제로 소수가 아닌 경우가 많기 때문에 추가적인 검증이 필요하다.</p>]]></content><author><name></name></author><category term="algorithm"/><category term="primenumber"/><category term="algorithm"/><summary type="html"><![CDATA[6k ± 1 최적화 방법]]></summary></entry><entry><title type="html">[백준] 14425번 문자열 집합 / C++</title><link href="https://mhoo999.github.io/blog/2024/boj14425/" rel="alternate" type="text/html" title="[백준] 14425번 문자열 집합 / C++"/><published>2024-05-12T00:00:00+00:00</published><updated>2024-05-12T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj14425</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj14425/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/14425">백준 14425번 문자열 집합</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strs</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">string</span> <span class="n">str</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>

		<span class="n">strs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">string</span> <span class="n">str</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">!=</span> <span class="n">strs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>n개의 문자열을 입력받고, m개의 문자열을 입력받는다. 중복되는 문자열이 몇개인지 출력하는 문제. 첫 시도에서는 간단하게 vector 컨테이너를 사용하여 for문으로 문자열을 찾았다. 시간초과. <code class="language-plaintext highlighter-rouge">O(1)</code>의 시간 복잡도로 원소를 찾을 수 있는 해쉬셋을 이용하여 해결.</p>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry><entry><title type="html">[백준] 2217번 로프 / C++</title><link href="https://mhoo999.github.io/blog/2024/boj2217/" rel="alternate" type="text/html" title="[백준] 2217번 로프 / C++"/><published>2024-05-11T00:00:00+00:00</published><updated>2024-05-11T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj2217</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj2217/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/2217">백준 2217번 로프</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>

		<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>n개의 숫자를 입력받는다. 입력받는 숫자는 각 로프가 최대 들어올릴 수 있는 중량을 의미한다. 첫 시도에서는 입력받는 숫자 중 가장 작은 숫자 * 총 입력 받은 숫자를 출력했다. 예제는 성공했지만, 역시나 실패. 하지만 10, 20, 25를 입력 받았을 땐, 가장 작은 숫자인 10 * 3 = 30 이지만, 20와 25만 사용한다면 40까지 가능하다. 그렇기 때문에 일단 입력받은 숫자를 내림차순으로 정렬하고, 차례로 <code class="language-plaintext highlighter-rouge">int x = vec[i] * (i + 1);</code> 수식을 진행하여 가장 큰 수를 찾아 해결했다.</p>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry><entry><title type="html">[백준] 18258번 큐 2 / C++</title><link href="https://mhoo999.github.io/blog/2024/boj18258/" rel="alternate" type="text/html" title="[백준] 18258번 큐 2 / C++"/><published>2024-05-10T00:00:00+00:00</published><updated>2024-05-10T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj18258</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj18258/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/18258">백준 18258번 큐 2</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Node</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">Node</span><span class="o">*</span> <span class="n">prevNode</span><span class="p">;</span>
	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">nextNode</span><span class="p">;</span>

	<span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">prevNode</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">nextNode</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Queue</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">front</span><span class="p">;</span>
	<span class="n">Node</span><span class="o">*</span> <span class="n">back</span><span class="p">;</span>

<span class="nl">public:</span>
	<span class="n">Queue</span><span class="p">()</span> <span class="o">:</span> <span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">front</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">back</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>

	<span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">auto</span> <span class="n">newNode</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
		<span class="n">Node</span><span class="o">*</span> <span class="n">newRawNode</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">front</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
			<span class="n">back</span> <span class="o">=</span> <span class="n">newRawNode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">back</span><span class="o">-&gt;</span><span class="n">nextNode</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
			<span class="n">newRawNode</span><span class="o">-&gt;</span><span class="n">prevNode</span> <span class="o">=</span> <span class="n">back</span><span class="p">;</span>
			<span class="n">back</span> <span class="o">=</span> <span class="n">newRawNode</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">Pop</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-1"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">front</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
				<span class="n">back</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">front</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">front</span><span class="o">-&gt;</span><span class="n">nextNode</span><span class="p">);</span>
				<span class="n">front</span><span class="o">-&gt;</span><span class="n">prevNode</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">size</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">Size</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">Empty</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'1'</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'0'</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">Front</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-1"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">Back</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-1"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">back</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Queue</span><span class="o">&gt;</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">string</span> <span class="n">str</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"push"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>

			<span class="n">q</span><span class="o">-&gt;</span><span class="n">Push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"pop"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">Pop</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"size"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"empty"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">Empty</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"front"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">Front</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="s">"back"</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">Back</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>최대 2,000,000 명령을 처리하는 큐를 만들었다. 큐 1 문제에서는 shared_ptr을 사용하여 쉽게 해결했는데, 같은 코드로 제출해보니 시간초과에 걸렸다. shared_ptr의 오버헤드가 문제일 것이라는 가정 하에 unique_ptr와 raw pointer로 변경하였더니 해결할 수 있었다.</p>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry><entry><title type="html">[백준] 1620번 나는야 포켓몬 마스터 이다솜 / C++</title><link href="https://mhoo999.github.io/blog/2024/boj1620/" rel="alternate" type="text/html" title="[백준] 1620번 나는야 포켓몬 마스터 이다솜 / C++"/><published>2024-05-09T00:00:00+00:00</published><updated>2024-05-09T00:00:00+00:00</updated><id>https://mhoo999.github.io/blog/2024/boj1620</id><content type="html" xml:base="https://mhoo999.github.io/blog/2024/boj1620/"><![CDATA[<h3 id="문제">#문제</h3> <p><a href="https://www.acmicpc.net/problem/1620">백준 1620번 나는야 포켓몬 마스터 이다솜</a></p> <h3 id="풀이">#풀이</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">string</span> <span class="n">book</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">bookIdx</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">string</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>

		<span class="n">book</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
		<span class="n">bookIdx</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">book</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bookIdx</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="정리">#정리</h3> <p>N개의 포켓몬을 순서대로 입력 받는다. 1-N까지가 입력받는 포켓몬의 번호다. 그리고 N+1 부터 5줄을 입력받는데, 숫자면 그 숫자에 맞는 포켓몬 이름을 출력하고, 이름이라면 해당 포켓몬의 번호를 출력하는 문제. 입력 받고, 각 번호에 맞는 포켓몬을 출력하는 것까지는 쉽다. 번호도 반복문을 사용하여 맞는 이름을 찾아 출력하면 되니까 큰 문제가 되지 않을 것이라 생각했다. 하지만 반복문을 사용할 경우 시간초과에 걸려 실패한다. 그래서 생각한 것이 해쉬맵이다. 포켓몬의 이름은 일반 배열에 받고, 인덱스는 해쉬맵에 받아 입력받은 명령이 숫자인지 아닌지 구분하여 출력하면 해결.</p>]]></content><author><name></name></author><category term="algorithm"/><category term="백준"/><category term="boj"/><category term="c++"/><category term="codingtest"/><category term="algorithm"/><summary type="html"><![CDATA[백준 C++ 풀이]]></summary></entry></feed>